
# TCP #

[wiki 传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)

> **传输控制协议**(Transmission Control Protocol-TCP) 是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议，*由IETF的RFC 793*定义。

> 在简化的计算机网络OSI模型中，它完成第四层传输层所指定的特殊功能。用户数据报协议(UDP) 是同一层内另一个重要的传输协议。

> 在**因特网协议族**(Internet prtocol)中，TCP是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

> 应用层向TCP层发送用于网络传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段(通常受该计算机连接的网络的数据链路层的最大传输单元(MTU)的限制)。之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。
> 
> TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认信息(ACK);如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。TCP用一个效验和函数来检验数据是否有错误，在发送和接收时都要计算效验和。

## 简介 ##

  数据在TCP层称为流(Stream),数据分组称为分段(Segment)。作为比较，数据在IP层称为Datagram,数据分组称为分片(Fragment)。UDP中分组称为Message

## 运作方式 ##

  TCP协议的运行可划分为三个阶段：**连接创建**(connection establishment)、**数据传送**(data transfer) 和 **连接终止**(connection termination)。操作系统将TCP连接抽象为套接字表示的本地端点(local end-point),作为编程接口给程序使用。在TCP连接的生命期内，本地端点要经历一系列的状态改变。

**创建通路**

  TCP用三次握手(或称三路握手，three-way handshake) 过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。

  一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端打开一个套接字(socket)然后监听来自另一方的连接，这就是通常所指的被动打开(passive open)。服务器端被被动打开以后，用户端就能开始创建主动打开(active open)。

   1. 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数**A**。
   2. 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为**A+1**,SYN/ACK包本身又有一个随机产生的序号**B**。
   3. 最后，客户端再发送一个ACK。此时包的序号被设定为**A+1**，而ACK的确认码则为**B+1**。当服务端收到这个ACK的时候，就完成了三次握手，并进入了连接创建状态。

  如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK,那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s，2s，4s，8s，16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要1s+2s+4s+8s+16s+32s = 63s,TCP才会断开这个连接。使用三个TCP参数来调整行为:tcp_synack_retries -- 减少重试次数；tcp_max_syn_backlog -- 增大SYN连接数；tcp_abort_on_overflow -- 决定超出能力时的行为。

**资源使用**

  主机收到一个TCP包时，用两端的IP地址与端口号来标识这个TCP包属于哪个session。使用一张表来存储所有的session，表中的每条称作Transmission Control Block(TCB)，tcb结构的定义包括连接使用的源端口、目的端口、目的ip、序号、应答序号、对方窗口大小、己方窗口大小、tcp状态、tcp输入/输出队列、应用层输出队列、tcp的重传有关变量等。

  服务器端的连接数量是无限的，只受内存的限制。客户端的连接数量，过去由于在发送第一个SYN到服务器之前需要先分配一个随机空闲的端口，这限制了客户端IP地址的对外发出连接的数量上限。从Linux4.2开始，有了socket选项IP_BIND_ADDRESS_NO_PORT,它通知Linux内核不保留usingbind使用端口号为0时内部使用的临时端口(ephemeral port)，在connect时会自动选择端口以组成独一无二的四元组(同一个客户端端口可用于连接不同的服务器套接字；同一个服务器端口可用于接收不同客户端套接字的连接)。

  对于不能确认的包、接收但还没读取的数据，都会占用操作系统的资源。

**数据传输**

  在TCP的数据传输状态，很多重要的机制保证了TCP的可靠性和强壮性。它们包括：使用序号，对收到的TCP报文段进行排序以及检测重复的数据；使用校验和检测报文段的错误，即无措传输；使用确认和计时器来检测和纠正丢包或延时；流控制(Flow control);拥塞控制(Congestion control);丢失包的重传。

**可靠传输**

  通常在每个tcp报文段中都有一对序号和确认号。TCP报文发送者称自己的字节流的编号为序号(*sequence number*),称接收到对方的字节流编号为确认号。TCP报文的接收者为了确保可靠性，在接收到一定数量的连续字节流后才发送确认。这是对TCP的一种扩展，称为选择确认(Selective Acknowledgement) 。 选择确认使得TCP接收者可以对乱序到达的数据块进行确认。每一个字节传输过后，SN号都会递增1.

  通过使用序号和确认号，TCP层可以把收到的报文段中的字节按正确的顺序交付给应用层。序号是32位无符号数，在它增大到(2^32)-1时，便会回绕到0.对于初始化序列号(ISN)的选择是TCP中关键的一个操作，它可以确保强壮性和安全性。

  TCP协议使用序号标识每段发出的字节的顺序，从而另一端接收数据时可以重建顺序，无惧传输时的包的乱序交付或丢包。在发送第一个包时(SYN包)，选择一个随机数作为序号的初值，以克制TCP序号预测攻击。

  发送确认包(Acks)，携带了接收到的对方发送来的字节流的编号，称为确认号，以告诉对方已经成功接收的数据流的字节位置。Ack并不意味着数据已经交付了上层应用程序。

  可靠性通过发送方检测到丢失的传输数据并重传这些数据。包括超时重传(Retransmission timeout -- RTO) 与重复累计确认 (duplicate cumulative acknowledgements -- DupAcks)。

**基于重复累计确认的重传**

  如果一个包(假设序号为100，即该包始于第100字节) 丢失，接收方就不能确认这个包及其以后的包，因为采用了累计ack。接收方在收到100以后的包时，发出对包含第99字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到3次对同一个包的确认，就重传最后一个未被确认的包。阈值设为3被证实可以减少乱序包导致的无作用的重传(spurious retransmission)现象。 **选择性确认**(SACK)的使用能明确反馈哪个包收到了，极大改善了TCP重传必要的包的能力。

**超时重传**

  发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。典型地，定时器的值设定为 **smoothed RTT  + max(G,4 × RTT variation )** 其中 **G** 是时钟粒度。进一步，如果重传定时器被触发，仍然没有收到确认包，定时器的值将被设为前次值的两倍(直到特定阈值)。这可对抗 **中间人攻击方式的拒绝服务攻击** ， 这种攻击愚弄发送者重传很多次导致接受者被压垮。

**数据传输举例**

   1. 发送方首先发送第一个包含序列号为1(可变化)和1460字节数的TCP报文段给接收方。接收方以一个没有数据的TCP报文来回复(只含报头)，用确认号1461来表示已完全收到并请求下一个报文段。
   2. 发送方然后发送第二个包含序列号为1461，长度为1460字节的数据的TC报文段给接收方。正常情况下，接收方以一个没有数据的TCP报文段来回复，用确认号2921(1461+1460)来表示已经完全收到并请求下一个报文段。发送接收这样继续下去。
   3. 然而当这些数据包都是相连的情况下，接收方没有必要每一次都回应。比如，他收到第1到5条TCP报文段，只需回应第五条就行了。在例子中第三条TCP报文段被丢失了，所以尽管他收到了第4和第5条，然而他只能回应第二条。
   4. 发送方在发送了第三条以后，没能收到回应，因此当时钟(timer)过时(expire)时，它重发第三条。(每次发送者发送一条TCP报文段后，都会再次启动一次时钟：RTT)。
   5. 这次第三条被成功接收，接收方可以直接确认第5条，因为4,5两条已收到。

**效验和**

  TCP的16位**效验和**(checksum)的计算和检验过程如下：发送者将TCP报文段的头部和数据部分的和计算出来，再对其求**反码**(一的补码)，就得到了校验和，然后将结果装入报文中传输。(这里用反码和的原因是这种方法的循环进位使校验和可以在16位、32位、64位等情况下的计算结果再叠加后相同) 接收者在收到报文后再按相同的算法计算一次校验和。这里使用的反码使得接收者不用再将校验和字段保存起来后清零，而可以直接将报文段连同校验和加总。如果计算结果是全部为一，那么就表示了报文的完整性和正确性。

  **注意：TCP校验和也包括了96位的伪头部，其中有源地址、目标地址、协议以及TCP的长度。这可以避免报文被错误的路由**。

  按现在的标准，TCP的校验和是一个比较脆弱的校验。出错概率高的数据链路层需要更高的能力来探测和纠正连接错误。TCP如果是在今天设计的，它很可能有一个32位的**CRC校验**来纠错，而不是使用校验和。但是通过在第二层使用通常的**CRC校验**或更完全一点的校验可以部分地弥补这种脆弱的校验。第二层是在TCP层和IP层之下的，比如PPP或以太网，它们使用了这些校验。但是这也并不意味着TCP的16位校验和是冗余的，对于因特网传输的观察，表明在受CRC校验保护的各跳之间，软件和硬件的错误通常也会在报文中引入错误，而端到端的TCP校验能够捕捉到大部分简单的错误。这就是应用中的端到端原则。

**流量控制**

  **流量控制**用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控。

  TCP使用**滑动窗口协议**实现流量控制。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口” 允许的字节数量。接收方可修改 “接收窗口” 的值。

  当接收方宣布接收窗口的值为0，发送方停止进一步发送数据，开始了“保持定时器” (persist timer) , 以避免因随后的修改接收窗口的数据包丢失使连接的双侧进入死锁，发送方无法发出数据直至收到接收方修改窗口的指示。当 “保持定时器” 到期时，TCP发送方尝试恢复发送一个小的ZWP包(Zero Window Probe) ，期待接收方回复一个带着新的接收窗口大小的确认包。一般ZWP包会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。

  如果接收方以很小的增量来处理到来的数据，它会发布一系列小的接收窗口。这被称作**愚蠢窗口综合症**，因为它在TCP的数据包中发送很少的一些字节，相对于TCP包头是很大的开销。解决这个问题，就要避免对小的window size做出响应，直到有足够大的window size再响应：

   - 接收端使用David D Clark算法：如果收到的数据导致window size小于某个值，可以直接ack把window给关闭了，阻止发送端再发数据。等到接收端处理了一些数据后window size大于等于了MSS,或者接收端buffer有一半为空，就可以把window打开让发送端再发数据过来。
   - 发送端使用Nagle算法来延时处理，条件一：Window Size >= MSS 或是 Data Size >= MSS;条件二：等待时间或是超时200ms,这两个条件有一个满足，才会发送数据，否则就是在积累数据。Nagle算法默认是打开的，所以对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性程序，需要关闭这个算法。可以在Socket设置TCP_NODELAY选项来关闭这个算法。

**拥塞控制**

  **拥塞控制**是发送方根据网络的承载情况控制分组的发送量，以获取高性能又能避免拥塞崩溃 (congestion collapse,网络性能下降几个数量级)。这在网络流之间产生近似**最大最小公平**分配。

  发送方与接收方根据确认包或者包丢失的情况，以及定时器，估计网络拥塞情况，从而修改数据流的行为，这称为拥塞控制或网络拥塞避免。

  TCP的现代实现包含四种互相影响的拥塞控制算法：**慢开始**、**拥塞避免**、**快速重传**、**快速恢复**。

  此外，发送方采取“超时重传” (retransmission timeout,RTO)，这是估计出**来回通信延迟**(RTT)以及RTT的方差。

  RFC793中定义的计算SRTT的经典算法：指数加权移动平均(Exponential weighted moving average)

   1. 先采样RTT,记下最近好几次的RTT值。
   2. 做平滑计算SRTT公式为：**SRTT = (α * SRTT) + ((1 - α) * RTT)**,其中α取值在0.8到0.9之间
   3. 计算RTO，公式: **RTO = min(UBOUND,max(LBOUND,(β * SRTT)))**,其中UBOUND是最大的timeout时间上限值，LBOUND是最小的timeout时间下限值，β值一般在1.3到2.0之间。

  1987年，出行计算RTT的**Karn算法**或TCP时间戳(RFC 1323)，最大的特点是——忽略重传，不把重传的RTT做采样。但是，如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重传所有的包(因为之前的RTO很小)，于是，因为重传的不算，所以，RTO就不会被更新，这是一个灾难。为此，Karn算法一发生重传，就对现有的RTO值翻倍。这就是Exponential backoff。

  1988年，在RFC 6298中给出**范·雅各布森**算法取平均以获得平滑往返延时(Smoothed Round Trip Time,SRTT),作为最终的RTT估计值。这个算法在被用在今天的TCP协议中：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/1f61694ef7af35e667516ca5836f49ebbc4ddab9)

  其中：DevRTT是Deviation RTT。在Linux下，α = 0.125，β = 0.25， μ = 1，∂= 4

  当前有很多TCP**拥塞控制算法**在研究中。

**最大分段大小**

  **最大分段大小**(MSS)是在单个分段中TCP愿意接受的数据的字节数最大值。MSS应当足够小以避免**IP分片**，它会导致丢包或过多的重传。在TCP连接创建时，双端在SYN报文中用MSS选项宣布各自的MSS,这是从双端各自直接相连的**数据链路层**的**最大传输单元**(MTU)的尺寸减去固定的IP首部和TCP首部长度。以太网MTU为1500字节，MSS值可达1460字节。使用IEEE 802.3的MTU为1492字节，MSS可达1452字节。如果目的IP地址为“非本地的”,MSS通常的默认值为536(这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。此外，发送方可用**传输路径MTU发现**(*RFC 1191*)推导出从发送方到接收方的网络路径上的最小MTU，以此动态调整MSS以避免网络**IP分片**。

  MSS发布也被称作“MSS协商” (MSS negotiation)。严格讲，这并非是协商出来一个统一的MSS值，TCP允许连接两端使用各自不同的MSS值。例如，这会发生在参与TCP连接的一台设备使用非常少的内存处理到来的TCP分组。

**选择确认**

  最初采取累计确认的TCP协议在丢包时效率很低。例如，假设通过10个分组发出了1万个字节的数据。如果第一个