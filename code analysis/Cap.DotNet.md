
**CAP.DotNetæºç è¿½è¸ªï¼ˆä¸€ï¼‰æ¶ˆæ¯æ˜¯å¦‚ä½•æ‰§è¡Œçš„ï¼Œæ‰§è¡Œååˆæ˜¯å¦‚ä½•æ‰§è¡Œå›è°ƒçš„**

----------

### åœºæ™¯ ###

.NET Core 3.1
nugetåŒ…ï¼šDotNetCore.CAP.RabbitMQ 3.0.2

### ç›®å½• ###

[CAP.DotNetæºç è¿½è¸ªï¼ˆä¸€ï¼‰æ¶ˆæ¯æ˜¯å¦‚ä½•æ‰§è¡Œçš„ï¼Œæ‰§è¡Œååˆæ˜¯å¦‚ä½•æ‰§è¡Œå›è°ƒçš„](https://www.cnblogs.com/monster17/p/12852266.html)

### å‰è¨€ ###

ä»¥å¯¹è¯ä¸ºå¼•ï¼Œæ¢³ç†æˆ‘ä»¬çš„é—®é¢˜:

*å°æ˜-èªæ˜ç»é¡¶çš„ç¨‹åºçŒ¿ï¼Œå°çº¢-ç»ç¾ç¨‹åºåª›*

å°çº¢:å°æ˜ï¼Œåœ¨CAPä¸­ï¼Œæˆ‘ä»¬é€šè¿‡**CapSubscribe**ç‰¹æ€§æ¥è®¢é˜…æ–¹æ³•ï¼Œè€Œæˆ‘ä»¬å†™çš„æ¶ˆæ¯å¤„ç†ä¸­ï¼Œè¿”å›å€¼ä¸€èˆ¬éƒ½æ˜¯void/Taskï¼Œé‚£ä¹ˆè¿™ä¸ªè¿”å›å€¼ç±»å‹æœ‰ä»€ä¹ˆç”¨å‘€æˆ–è€…è¯´è¿™ä¸ªè¿”å›å€¼æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ

å°æ˜ä¸€çœ‹è¡¨ç°çš„æœºä¼šæ¥äº†ï¼Œé©¬ä¸Šå›å¤äº†ä¸€å¥ï¼šç™¾å› å¿…æœ‰æœï¼Œæ—¢ç„¶æœ‰è¿”å›ç±»å‹è¿™ä¸ªä¸œè¥¿ï¼Œé‚£ä¹ˆCAPè®¾è®¡è€…è‚¯å®šä¼šåˆ©ç”¨è¿™ä¸€ç‚¹æ¥è¿›è¡Œåº”ç”¨ï¼Œä¸ä¼šæ— æ•…å¿½è§†è¿™ä¸ªåŠŸèƒ½çš„

å°çº¢ï¼šå°æ˜ï¼Œé‚£å®ƒåˆ°åº•æœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿ

å°æ˜ï¼šæ—¢ç„¶æƒ³çŸ¥é“å®ƒçš„ä½œç”¨ï¼Œé‚£ä¹ˆå°±åº”è¯¥å»å­¦ä¹ å®ƒçš„æ¶ˆæ¯æ‰§è¡ŒåŸç†ï¼Œåˆ†æå…¶æ‰§è¡Œè¿‡ç¨‹ï¼Œè‡ªç„¶å°±æ˜ç™½å®ƒçš„è¿”å›å€¼çš„ä½œç”¨äº†ã€‚

å°çº¢ï¼šå“‡ï¼Œé—®é¢˜ä¸€ä¸‹ä»è¿”å›å€¼çš„ä½œç”¨ä¸Šå‡åˆ°äº†CAPæ‰§è¡ŒåŸç†äº†ï¼Œå°æ˜ï¼Œå¿«ç»™æˆ‘è®²è®²å‘€ğŸ˜‰

å°æ˜å¿ƒæƒ³æ˜¯æ—¶å€™è¡¨æ¼”çœŸæ­£çš„æŠ€æœ¯äº†~âœ¨ @#^*$&(^#@*&(^$#@(

### æ­£æ–‡ ###

ä»åº”ç”¨å±‚é¢æ¥çœ‹ï¼Œæˆ‘ä»¬ä½¿ç”¨CAPä¸»è¦å°±æ˜¯ä½¿ç”¨å®ƒçš„æ¶ˆæ¯å‘é€å’Œè®¢é˜…ï¼Œæ—¢ç„¶è¦å­¦ä¹ å®ƒçš„æ‰§è¡ŒåŸç†ï¼Œé‚£ä¹ˆå°±ç›´æ¥ä»æ¶ˆæ¯å‘é€å‡ºå‘æ¥å­¦ä¹ 

**MQå‘é€**

ä»¥å¸¸ç”¨æƒ…å†µä¸ºä¾‹ï¼Œæˆ‘ä»¬é€šè¿‡æ³¨å†Œçš„**ICapPublisher**ä¸‹çš„**PublishAsync**æ¥å‘é€æ¶ˆæ¯

é¦–å…ˆå…ˆçœ‹ä¸€ä¸‹æ–¹æ³•å®šä¹‰ï¼š

    Task PublishAsync<T>(string name, [CanBeNull] T contentObj, string callbackName = null, CancellationToken cancellationToken = default);

name - ä¸»é¢˜åç§°æˆ–äº¤æ¢è·¯ç”±å™¨å¯†é’¥ã€‚

contentObj - æ¶ˆæ¯å†…å®¹

callbackName - callback subscriber name å›è°ƒçš„è®¢é˜…è€…åç§°

cancellationToken - ç•¥

é‚£ä¹ˆå®ƒæ˜¯æ€ä¹ˆæ‰§è¡Œå‘¢?

  æ—¢ç„¶æ˜¯é€šè¿‡**ICapPublisher**è°ƒç”¨ï¼Œé‚£ä¹ˆæ‰¾åˆ°**ICapPublisher**çš„å®ç°è€…ä¸å°±çŸ¥é“äº†ï¼Œæ›´ä¸ºç›´æ¥çš„æ–¹æ³•æ˜¯æŸ¥æ‰¾æ³¨å…¥çš„åœ°æ–¹ï¼ŒæŸ¥çœ‹**ICapPublisher**çš„å¯¹åº”å®ç°ç±»

é€šè¿‡**Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions**æ–¹æ³•**AddCAP**å¯çŸ¥å…¶å®ç°ä¸º**DotNetCore.CAP.Internal.CapPublisher** (ps:CAPæ”¯æŒè‡ªè¡Œå®ç°ICapPublisher)

æŸ¥çœ‹å®ç°å®šä¹‰ï¼š

	public Task PublishAsync<T>(string name, T value, string callbackName = null,
            CancellationToken cancellationToken = default)
    {
        return Task.Run(() => Publish(name, value, callbackName), cancellationToken);
    }

	public void Publish<T>(string name, T value, string callbackName = null)
    {
        var header = new Dictionary<string, string>
        {
            {Headers.CallbackName, callbackName}
        };

        Publish(name, value, header);
    }

	public void Publish<T>(string name, T value, IDictionary<string, string> headers)// åˆ å‡ç‰ˆ
    {
		// å”¯ä¸€idç”Ÿæˆ
        var messageId = SnowflakeId.Default().NextId().ToString();

		headers.Add(Headers.MessageId, messageId);

		// capé€šè¿‡æ­¤å†…å®¹æ¥éªŒè¯æ¶ˆæ¯ç±»å‹æ˜¯å¦åŒ¹é…
        headers.Add(Headers.Type, typeof(T).FullName);
		headers.Add(Headers.MessageName, name);
		headers.Add(Headers.Type, typeof(T).FullName);
        headers.Add(Headers.SentTime, DateTimeOffset.Now.ToString());
        if (!headers.ContainsKey(Headers.CorrelationId))
        {
            headers.Add(Headers.CorrelationId, messageId);
            headers.Add(Headers.CorrelationSequence, 0.ToString());
        }

        var message = new Message(headers, value);
		// â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘å°è£…æ¶ˆæ¯ä½“â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘

		long? tracingTimestamp = null;
        try
        {
            tracingTimestamp = TracingBefore(message);

            if (Transaction.Value?.DbTransaction == null)
            {
				// æ­¤å¤„è¿”å›ç”¨å­˜å‚¨åçš„æ•°æ®æ ¼å¼è¡¨ç¤ºçš„æ¶ˆæ¯ä½“
                var mediumMessage = _storage.StoreMessage(name, message);

                TracingAfter(tracingTimestamp, message);

                _dispatcher.EnqueueToPublish(mediumMessage);
            }
            else
            {
                var transaction = (CapTransactionBase)Transaction.Value;

                var mediumMessage = _storage.StoreMessage(name, message, transaction.DbTransaction);

                TracingAfter(tracingTimestamp, message);

                transaction.AddToSent(mediumMessage);

                if (transaction.AutoCommit)
                {
                    transaction.Commit();
                }
            }
			// â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘å­˜å‚¨æ¶ˆæ¯å¹¶å°è¯•å‘é€â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘
        }
        catch (Exception e)
        {
            TracingError(tracingTimestamp, message, e);

            throw;
        }

	}

é€šè¿‡åˆ†æè¿™é‡Œå‘é€åŒ…æ‹¬ï¼š

1.**å”¯ä¸€idçš„ç”Ÿæˆ** -> å¯è‡ªè¡ŒæŸ¥çœ‹SnowflakeIdå®ç°

2.**æ•°æ®åº“å­˜å‚¨** -> å¯è‡ªè¡ŒæŸ¥çœ‹MySqlæˆ–Sqlserverçš„å®ç°

3.**TracingAfter(tracingTimestamp, message);** -> å¯æŸ¥çœ‹**System.Diagnostics.DiagnosticListener** çš„åº”ç”¨

4.**_dispatcher.EnqueueToPublish(mediumMessage);** -> å¯æŸ¥çœ‹**System.Threading.Channels.Channel** çš„åº”ç”¨

5.**CapTransactionBase** -> capçš„äº‹åŠ¡å¤„ç† (ç•¥)

å¥½äº†åˆ°æ­¤å‘é€å°±ç»“æŸäº†ï¼Œç®€å•æ¥è¯´å°±æ˜¯ ç”Ÿæˆæ¶ˆæ¯ + æ¶ˆæ¯å­˜å‚¨ï¼Œé‚£ä¹ˆè®¢é˜…æ˜¯åœ¨å“ªé‡Œè¢«è§¦å‘å‘¢ï¼Ÿ

è¿™é‡Œå¼•å‡ºä¸€ä¸ªæ–°ç±»**Microsoft.Extensions.Hosting.BackgroundService**ï¼Œdesc:ç”¨äºå®ç°é•¿æ—¶é—´è¿è¡Œçš„ IHostedService çš„åŸºç±»ã€‚

è®©æˆ‘ä»¬å›åˆ°**AddCAP**ä¸­ï¼Œåœ¨æœ€åå“ªé‡Œä½¿ç”¨äº†**services.AddHostedService<Bootstrapper>();**

æŸ¥çœ‹**Bootstrapper**çš„å®šä¹‰:

	internal class Bootstrapper : BackgroundService, IBootstrapper

åˆ°äº†è¿™é‡Œ**CAP**çš„ä¸€ä¸ªå¤§è‡´çš„è½®å»“å°±æœ‰äº†ï¼Œ

å‘é€ -> ç»„è£…æ¶ˆæ¯+æ¶ˆæ¯å­˜å‚¨+äº‹åŠ¡(é…åˆç€Channel,DiagnosticListener)

è®¢é˜…/æ¥æ”¶æ¶ˆæ¯ -> åˆå§‹å¯åŠ¨ä¸€ä¸ª**BackgroundService**å»æ‰«ææ¶ˆæ¯è¿›è¡Œæ‰§è¡Œ

æ—¢ç„¶æ‰¾åˆ°äº†æ¥æ”¶å·¥ä½œçš„åœ°æ–¹ï¼Œé‚£æˆ‘ä»¬å°±æ¥çœ‹çœ‹å®ƒæ€ä¹ˆå®ç°çš„å§ï¼š**Bootstrapper.ExecuteAsync**

	protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await BootstrapAsync(stoppingToken);
    }

	public async Task BootstrapAsync(CancellationToken stoppingToken)
    {
        _logger.LogDebug("### CAP background task is starting.");

        try
        {
            await Storage.InitializeAsync(stoppingToken);
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Initializing the storage structure failed!");
        }

        stoppingToken.Register(() =>
        {
            _logger.LogDebug("### CAP background task is stopping.");

            foreach (var item in Processors)
            {
                try
                {
                    item.Dispose();
                }
                catch (OperationCanceledException ex)
                {
                    _logger.ExpectedOperationCanceledException(ex);
                }
            }
        });

        await BootstrapCoreAsync();

        _logger.LogInformation("### CAP started!");
    }

â‘  **await Storage.InitializeAsync(stoppingToken);** è§åæ€æ„ï¼Œåº”è¯¥æ˜¯å­˜å‚¨ç›¸å…³çš„åˆå§‹åŒ–ï¼Œä¾‹å¦‚ï¼šCAPåœ¨ä½¿ç”¨dbå­˜å‚¨æ—¶åˆå§‹åŒ–ä¼šè‡ªåŠ¨åˆ›å»ºå¯¹åº”çš„è¡¨

æŸ¥çœ‹**Processors**çš„å®šä¹‰ï¼š

	private IEnumerable<IProcessingServer> Processors { get; }

â‘¡ å½“**stoppingToken**å–æ¶ˆæ—¶é‡Šæ”¾æ‰€æœ‰çš„IProcessingServer

â‘¢ await BootstrapCoreAsync(); 

	protected virtual Task BootstrapCoreAsync()
    {
        foreach (var item in Processors)
        {
            try
            {
                item.Start();
            }
            catch (Exception ex)
            {
                _logger.ProcessorsStartedError(ex);
            }
        }

        return Task.CompletedTask;
    }

å³æ˜¯å¯åŠ¨æ‰€æœ‰çš„**IProcessingServer**

é‚£ä¹ˆ**IProcessingServer**å…·ä½“æœ‰å“ªäº›å®ç°å‘¢ï¼Ÿ

æ—¢ç„¶æœ‰ä½¿ç”¨çš„åœ°æ–¹å°±è‚¯å®šæœ‰æ³¨å†Œçš„åœ°æ–¹ï¼Œå†æ¬¡å›åˆ°**AddCAP**æ³¨å…¥å¤„ï¼Œé€šè¿‡æºç å¯ä»¥çœ‹åˆ°ï¼š

	services.TryAddEnumerable(ServiceDescriptor.Singleton<IProcessingServer, CapProcessingServer>());
	services.TryAddEnumerable(ServiceDescriptor.Singleton<IProcessingServer, ConsumerRegister>());

æ³¨å…¥äº†**CapProcessingServer**å’Œ**ConsumerRegister**

#### CapProcessingServer ####

ç•¥

#### ConsumerRegister ####

æ‰¾åˆ°**ConsumerRegister.Start**:

	public void Start()
	{
	    var groupingMatches = _selector.GetCandidatesMethodsOfGroupNameGrouped();
	
	    foreach (var matchGroup in groupingMatches)
	    {
	        for (int i = 0; i < _options.ConsumerThreadCount; i++)
	        {
	            Task.Factory.StartNew(() =>
	            {
	                try
	                {
	                    using (var client = _consumerClientFactory.Create(matchGroup.Key))
	                    {
	                        _serverAddress = client.BrokerAddress;
	
	                        RegisterMessageProcessor(client);
	
	                        client.Subscribe(matchGroup.Value.Select(x => x.Attribute.Name));
	
	                        client.Listening(_pollingDelay, _cts.Token);
	                    }
	                }
	                catch (OperationCanceledException)
	                {
	                    //ignore
	                }
	                catch (BrokerConnectionException e)
	                {
	                    _isHealthy = false;
	                    _logger.LogError(e, e.Message);
	                }
	                catch (Exception e)
	                {
	                    _logger.LogError(e, e.Message);
	                }
	            }, _cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default);
	        }
	    }
	    _compositeTask = Task.CompletedTask;
	}

*step by step*:

a:è·å–æ‰€æœ‰ç»„åˆ«åŠå…¶ç›¸å…³ä¿¡æ¯[å³è·å–æ‰€æœ‰æœ‰**TopicAttribute**ç‰¹æ€§æ ‡è®°çš„ä¿¡æ¯(from Interface or Controller)]

	var groupingMatches = _selector.GetCandidatesMethodsOfGroupNameGrouped();

å…·ä½“å®ç°ï¼ˆç•¥ï¼šé€šè¿‡TypeæŸ¥æ‰¾Attributeï¼Œå†ç­›é€‰ç›¸ç¬¦åˆçš„ä¿¡æ¯ï¼‰

b:éå†è¿™äº›ç»„åˆ«ï¼Œé€šè¿‡ç»„åˆ«åç§°ï¼Œåˆ›å»ºç›¸åº”çš„æ¶ˆè´¹è€…**client**

c:æ³¨å†Œclientçš„æ¶ˆæ¯æ¥æ”¶äº‹ä»¶

	 RegisterMessageProcessor(client);

d:å¼€å¯è®¢é˜…

	client.Subscribe(matchGroup.Value.Select(x => x.Attribute.Name));

e:å¼€å¯ç›‘å¬

	client.Listening(_pollingDelay, _cts.Token);

å¯è§**ConsumerRegister.Start**çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯æ¶ˆè´¹è€…çš„å‰ç½®åˆå§‹åŒ–ï¼Œæ ¹æ®ä»£ç ä¸­çš„ç‰¹æ€§æ ‡è®°å¼€å¯ç›¸åº”çš„è®¢é˜…å’Œç›‘å¬ï¼Œæ—¢ç„¶æ¶ˆæ¯ç›‘å¬å·²ç»å¼€å¯äº†ï¼Œé‚£æ¶ˆæ¯æ˜¯å¦‚ä½•å¤„ç†çš„å‘¢ï¼Ÿ

è®©æˆ‘ä»¬å›è¿‡å¤´æ¥å…³æ³¨â€œæ³¨å†Œclientçš„æ¶ˆæ¯æ¥æ”¶äº‹ä»¶â€ï¼Œâ€œæ³¨å†Œclientçš„æ¶ˆæ¯æ¥æ”¶äº‹ä»¶â€å³æ˜¯å®šä¹‰æ¶ˆæ¯çš„å…·ä½“å®ç°ï¼ŒæŸ¥çœ‹æºç ï¼š

	private void RegisterMessageProcessor(IConsumerClient client)
	{
	    client.OnMessageReceived += async (sender, transportMessage) =>
	    {
	        _logger.MessageReceived(transportMessage.GetId(), transportMessage.GetName());
	
	        long? tracingTimestamp = null;
	        try
	        {
	            tracingTimestamp = TracingBefore(transportMessage, _serverAddress);
	
	            var name = transportMessage.GetName();
	            var group = transportMessage.GetGroup();
	
	            Message message;
	
	            var canFindSubscriber = _selector.TryGetTopicExecutor(name, group, out var executor);
	            try
	            {
	                if (!canFindSubscriber)
	                {
	                    var error = $"Message can not be found subscriber. Name:{name}, Group:{group}. {Environment.NewLine} see: https://github.com/dotnetcore/CAP/issues/63";
	                    var ex = new SubscriberNotFoundException(error);
	
	                    TracingError(tracingTimestamp, transportMessage, client.BrokerAddress, ex);
	
	                    throw ex;
	                }
	
	                var type = executor.Parameters.FirstOrDefault(x => x.IsFromCap == false)?.ParameterType;
	                message = await _serializer.DeserializeAsync(transportMessage, type);
	            }
	            catch (Exception e)
	            {
	                transportMessage.Headers.Add(Headers.Exception, nameof(SerializationException) + "-->" + e.Message);
	                var dataUri = $"data:{transportMessage.Headers[Headers.Type]};base64," + Convert.ToBase64String(transportMessage.Body);
	                message = new Message(transportMessage.Headers, dataUri);
	            }
	
	            if (message.HasException())
	            {
	                var content = StringSerializer.Serialize(message);
	
	                _storage.StoreReceivedExceptionMessage(name, group, content);
	
	                client.Commit(sender);
	
	                try
	                {
	                    _options.FailedThresholdCallback?.Invoke(new FailedInfo
	                    {
	                        ServiceProvider = _serviceProvider,
	                        MessageType = MessageType.Subscribe,
	                        Message = message
	                    });
	
	                    _logger.ConsumerExecutedAfterThreshold(message.GetId(), _options.FailedRetryCount);
	                }
	                catch (Exception e)
	                {
	                    _logger.ExecutedThresholdCallbackFailed(e);
	                }
	
	                TracingAfter(tracingTimestamp, transportMessage, _serverAddress);
	            }
	            else
	            {
	                var mediumMessage = _storage.StoreReceivedMessage(name, group, message);
	                mediumMessage.Origin = message;
	
	                client.Commit(sender);
	
	                TracingAfter(tracingTimestamp, transportMessage, _serverAddress);
	
	                _dispatcher.EnqueueToExecute(mediumMessage, executor);
	            }
	        }
	        catch (Exception e)
	        {
	            _logger.LogError(e, "An exception occurred when process received message. Message:'{0}'.", transportMessage);
	
	            client.Reject(sender);
	
	            TracingError(tracingTimestamp, transportMessage, client.BrokerAddress, e);
	        }
	    };
	
	    client.OnLog += WriteLog;
	}

*side by side~*

a: æ³¨å†Œæ¥æ”¶æ—¶çš„å®ç°

	client.OnMessageReceived += async (sender, transportMessage) =>

æŸ¥çœ‹**OnMessageReceived**å®šä¹‰ï¼š

	event EventHandler<TransportMessage> OnMessageReceived;

æ•…æ­¤å¤„å°±æ˜¯æ·»åŠ ä¸€ä¸ªå§”æ‰˜å®ç°ï¼Œé‚£ä¹ˆå…·ä½“çš„å®ç°ä¾¿æ˜¯æˆ‘ä»¬çš„æ¶ˆæ¯å¤„ç†äº†

b: è·å–æ¶ˆæ¯è®¢é˜…(æ‰§è¡Œ)è€…

	var canFindSubscriber = _selector.TryGetTopicExecutor(name, group, out var executor);

æŸ¥æ‰¾æˆ‘ä»¬çš„æ¶ˆæ¯æ‰§è¡Œè€…(æ ¹æ®name,group) [å†…éƒ¨å®ç°ç•¥ï¼šåå°„é…åˆç‰¹æ€§]

c: è·å–æ¶ˆæ¯å†…å®¹

	var type = executor.Parameters.FirstOrDefault(x => x.IsFromCap == false)?.ParameterType;
    message = await _serializer.DeserializeAsync(transportMessage, type);

 æŸ¥çœ‹**_serializer**å®šä¹‰ï¼š

	private readonly ISerializer _serializer;

 å…·ä½“è·å–ï¼š

	_serializer = serviceProvider.GetService<ISerializer>();

 *æ•…æˆ‘ä»¬å¯ä»¥é€šè¿‡å®ç°ISerializerå†è¿›è¡Œæ³¨å…¥ï¼Œå®ç°æˆ‘ä»¬è‡ªå·±çš„æ¶ˆæ¯è§£æ*

 é»˜è®¤å®ç°ï¼šç•¥[å¯è‡ªè¡ŒæŸ¥çœ‹DotNetCore.CAP.Serialization.JsonUtf8Serializer]

d: å­˜å‚¨æ¥æ”¶æ¶ˆæ¯

	var mediumMessage = _storage.StoreReceivedMessage(name, group, message);

 åœ¨CAPçš„dbå­˜å‚¨ä¸­ï¼Œæœ‰ç€**published**å’Œ**received**ä¸¤ä¸ªè¡¨ï¼Œå‘é€å­˜å‚¨**published**ï¼Œæ¥æ”¶å­˜å‚¨**received**

e: å¤„ç†æ¶ˆæ¯

	_dispatcher.EnqueueToExecute(mediumMessage, executor);

 æŸ¥çœ‹å…¶å®šä¹‰ï¼š

	private readonly IDispatcher _dispatcher;

 ä¹Ÿæ˜¯å’Œ**_serializer**ç±»ä¼¼é€šè¿‡IOCå®¹å™¨è·å–

ç„¶åè®©æˆ‘ä»¬å›åˆ°**AddCAP**æŸ¥çœ‹å…¶æ³¨å…¥ç±»

	services.TryAddSingleton<IDispatcher, Dispatcher>();

æŸ¥çœ‹**Dispatcher.EnqueueToExecute**å®ç°ï¼š

	public void EnqueueToExecute(MediumMessage message, ConsumerExecutorDescriptor descriptor)
    {
        _receivedChannel.Writer.TryWrite((message, descriptor));
    }

ä¹Ÿæ˜¯å’Œå‘é€ä¸€æ ·ï¼Œé€šè¿‡**Channel**è¿›è¡Œä¼ é€’ï¼Œå¥½äº†ï¼Œæˆ‘ä»¬å°±æ¥çœ‹çœ‹è¿™ä¸ª**_receivedChannel**çš„å®šä¹‰ï¼š

	private readonly Channel<(MediumMessage, ConsumerExecutorDescriptor)> _receivedChannel;

ç§æœ‰å­—æ®µ-ã€‹å¤–ç•Œæ— æ³•è®¿é—®ï¼Œé‚£ä¹ˆå¤„ç†è¦ä¸åœ¨å­ç±»ä¸­ï¼Œè¦ä¸å°±æ˜¯ç›´æ¥åœ¨æ­¤ç±»ä¸­ï¼ŒæŸ¥çœ‹**Dispatcher**çš„æ„é€ ï¼š

	public Dispatcher(ILogger<Dispatcher> logger,
            IMessageSender sender,
            IOptions<CapOptions> options,
            ISubscribeDispatcher executor)
    {
        _logger = logger;
        _sender = sender;
        _executor = executor;

        _publishedChannel = Channel.CreateUnbounded<MediumMessage>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
        _receivedChannel = Channel.CreateUnbounded<(MediumMessage, ConsumerExecutorDescriptor)>();

        Task.Factory.StartNew(Sending, _cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default);

        Task.WhenAll(Enumerable.Range(0, options.Value.ConsumerThreadCount)
            .Select(_ => Task.Factory.StartNew(Processing, _cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default)).ToArray());
    }

a: åˆå§‹åŒ–
	_receivedChannel = Channel.CreateUnbounded<(MediumMessage, ConsumerExecutorDescriptor)>();


çœ‹çœ‹**CreateUnbounded**çš„è¯´æ˜ï¼š

	Creates an unbounded channel usable by any number of readers and writers concurrently.
	åˆ›å»ºå¯ç”±ä»»æ„æ•°é‡çš„è¯»å–å™¨å’Œå†™å…¥å™¨å¹¶å‘ä½¿ç”¨çš„æ— é™åˆ¶é€šé“ã€‚

ä¸€ä¸ªå…è®¸å¹¶å‘å¤„ç†çš„é€šé“?

b: ä½¿ç”¨

	Task.WhenAll(Enumerable.Range(0, options.Value.ConsumerThreadCount)
    .Select(_ => Task.Factory.StartNew(Processing, _cts.Token, TaskCreationOptions.LongRunning, TaskScheduler.Default)).ToArray());

åˆ›å»ºäº†**options.Value.ConsumerThreadCount**ä¸ª**Task**(å¹¶è®¾ç½®**TaskCreationOptions.LongRunning**-é•¿æœŸè¿è¡Œ)

å†æŸ¥çœ‹å…¶**Processing**å®ç°ï¼š

	private async Task Processing()
    {
        try
        {
            while (await _receivedChannel.Reader.WaitToReadAsync(_cts.Token))
            {
                while (_receivedChannel.Reader.TryRead(out var message))
                {
                    await _executor.DispatchAsync(message.Item1, message.Item2, _cts.Token);
                }
            }
        }
        catch (OperationCanceledException)
        {
            // expected
        }
    }
	
æŸ¥çœ‹**ChannelReader<T>.WaitToReadAsync**è¯´æ˜ï¼šè¿”å›å°†åœ¨æœ‰æ•°æ®å¯ä¾›è¯»å–æ—¶å®Œæˆçš„ ValueTask<TResult>ã€‚

**TryRead**ä¾¿æ˜¯å–å‡ºæ¶ˆæ¯

<ä¼ªä»£ç >:

	å¾ªç¯(ç­‰å¾…Channelä¸­æœ‰æ•°æ®å†™å…¥)
	{
		å¾ªç¯(å°è¯•ä»é€šé“ä¸­è¯»å–é¡¹)
		{
			å¤„ç†æ¶ˆæ¯
		}
	}

æ¶ˆæ¯å¤„ç†ï¼š

	 await _executor.DispatchAsync(message.Item1, message.Item2, _cts.Token);

ç»“åˆæ„é€ å’Œ**Dispatcher**çš„æ„å»ºå¯ä»¥çœ‹å‡º**_executor**æ˜¯é€šè¿‡IOCå®¹å™¨è·å–çš„ï¼Œå†æ¬¡æŸ¥çœ‹**AddCAP**çš„æ³¨å†Œï¼š

	services.TryAddSingleton<ISubscribeDispatcher, SubscribeDispatcher>();

æŸ¥æ‰¾**SubscribeDispatcher.DispatchAsync**

	public async Task<OperateResult> DispatchAsync(MediumMessage message, ConsumerExecutorDescriptor descriptor, CancellationToken cancellationToken)
    {
        bool retry;
        OperateResult result;
        do
        {
            var executedResult = await ExecuteWithoutRetryAsync(message, descriptor, cancellationToken);
            result = executedResult.Item2;
            if (result == OperateResult.Success)
            {
                return result;
            }
            retry = executedResult.Item1;
        } while (retry);

        return result;
    }

è°ƒç”¨**ExecuteWithoutRetryAsync**å¹¶è®¾è®¡äº†é‡è¯•æœºåˆ¶

	private async Task<(bool, OperateResult)> ExecuteWithoutRetryAsync(MediumMessage message, ConsumerExecutorDescriptor descriptor, CancellationToken cancellationToken)
    {
        if (message == null)
        {
            throw new ArgumentNullException(nameof(message));
        }

        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            var sp = Stopwatch.StartNew();

            await InvokeConsumerMethodAsync(message, descriptor, cancellationToken);

            sp.Stop();

            await SetSuccessfulState(message);

            _logger.ConsumerExecuted(sp.Elapsed.TotalMilliseconds);

            return (false, OperateResult.Success);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"An exception occurred while executing the subscription method. Topic:{message.Origin.GetName()}, Id:{message.DbId}");

            return (await SetFailedState(message, ex), OperateResult.Failed(ex));
        }
    }

 1.æ ¸å¿ƒæ‰§è¡Œ**await InvokeConsumerMethodAsync(message, descriptor, cancellationToken);**

 2.å¼‚å¸¸å¤„ç†**(await SetFailedState(message, ex), OperateResult.Failed(ex));** ï¼š ç•¥

æŸ¥çœ‹**SubscribeDispatcher.InvokeConsumerMethodAsync**:

	private async Task InvokeConsumerMethodAsync(MediumMessage message, ConsumerExecutorDescriptor descriptor, CancellationToken cancellationToken)
    {
        var consumerContext = new ConsumerContext(descriptor, message.Origin);
        var tracingTimestamp = TracingBefore(message.Origin, descriptor.MethodInfo);
        try
        {
            var ret = await Invoker.InvokeAsync(consumerContext, cancellationToken);

            TracingAfter(tracingTimestamp, message.Origin, descriptor.MethodInfo);

            if (!string.IsNullOrEmpty(ret.CallbackName))
            {
                var header = new Dictionary<string, string>()
                {
                    [Headers.CorrelationId] = message.Origin.GetId(),
                    [Headers.CorrelationSequence] = (message.Origin.GetCorrelationSequence() + 1).ToString()
                };

                await _provider.GetService<ICapPublisher>().PublishAsync(ret.CallbackName, ret.Result, header, cancellationToken);
            }
        }
        catch (OperationCanceledException)
        {
            //ignore
        }
        catch (Exception ex)
        {
            var e = new SubscriberExecutionFailedException(ex.Message, ex);

            TracingError(tracingTimestamp, message.Origin, descriptor.MethodInfo, e);

            throw e;
        }
    }

 1.æ ¸å¿ƒæ‰§è¡Œï¼š

	var ret = await Invoker.InvokeAsync(consumerContext, cancellationToken);

 åˆæ˜¯ä¸€ä¸ªé€šè¿‡IOCå®¹å™¨è·³è½¬æ‰§è¡Œï¼Œå…·ä½“æ‰§è¡Œï¼šç•¥-é€šè¿‡**consumerContext**å‚æ•°å€¼å’Œåå°„æ‹¿åˆ°å¯¹åº”æ‰§è¡Œæ–¹æ³•å¹¶é€šè¿‡IOCå®¹å™¨è·å–å¯¹åº”çš„å¯¹è±¡ï¼Œæ‰§è¡Œç›¸åº”çš„æ–¹æ³•

 2.å›è°ƒå¤„ç†

	await _provider.GetService<ICapPublisher>().PublishAsync(ret.CallbackName, ret.Result, header, cancellationToken);

å†æ”¾ä¸€ä¸‹æ–¹æ³•å®šä¹‰

	Task PublishAsync<T>(string name, [CanBeNull] T contentObj, IDictionary<string, string> headers, CancellationToken cancellationToken = default);

 æ‰€ä»¥æœ€ç»ˆç­”æ¡ˆå°±æ˜¯ï¼š**å½“å‘å¸ƒæ—¶è®¾ç½®äº†CallbackNameåï¼Œå½“æ¶ˆæ¯æ‰§è¡Œå®Œåï¼Œä¼šå‘å¸ƒä¸€ä¸ªä»¥CallbackNameä¸ºname,æ¶ˆæ¯è¿”å›å€¼ä¸ºæ¶ˆæ¯ä½“çš„æ¶ˆæ¯**

>>>>>å°çº¢:å°æ˜å¥½æ„Ÿåº¦+100~<<<<<

----------
å‚è€ƒåšæ–‡ï¼š

[è°ˆè°ˆ.NET Coreä¸­åŸºäºGeneric Hostæ¥å®ç°åå°ä»»åŠ¡](https://www.cnblogs.com/catcher1994/p/9961228.html)
