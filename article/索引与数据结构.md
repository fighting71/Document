
- **索引**是帮助MySQL/Sqlserver高效获取数据的**排好序**的**数据结构**

- 索引结构存储在文件中

- 索引结构
	- 二叉树
	- 红黑树
	- HASH
	- BTREE



## binary search tree ##

二叉树存储示例：

![示例图](https://i.ibb.co/wQKzW02/binary-search-tree.png)

结论：当数据为递增时，树结构具体表现类似于链表结构，当查找的数据在比较后面的节点时，会查找多次 

即 二叉树容易导致高度增大，会增加查找磁盘IO频率(例如：在插入递增时会退化为链表)

如何避免退化为链表？

## red/black tree ##

红黑树存储示例：

![示例图](<a href="https://imgbb.com/"><img src="https://i.ibb.co/RpwfDK9/red-black-tree.png" alt="red-black-tree" border="0"></a>)

好处：

  会自动支持平衡旋转

劣势：

  当数据量较大时，依然会导致高度很高，从而导致有些数据的获取会频繁IO

如何降低树的高度？

 既然要高度低，又要存储的数据多，那么为什么不在一个节点中存储多个索引呢

既然一个节点可以存储多个索引，为什么不在一个节点中存储所有索引？

 当数据过多时，节点占用空间较大，为了获取一个数据，加载几G数据不划算。

## b tree ##


## b+ tree ##

*叶子节点：无子节点的节点*

多叉平衡树

与b tree的区别：
 
- 非叶子节点不存储data,只存储索引(冗余),可以放更多的索引

- 叶子节点包含所有索引字段(在mysql中 不同数据引擎，存储方式有所不同 所有字段/数据指针(参考回表))

- 叶子节点用指针连接，提高区间访问的性能。

为什么b+ tree 要把数据移到叶子节点上？

  1.方便范围查询

  2.让非叶子节点存储更多的索引，降低树的高度。

**聚集索引vs非聚集索引**

聚集索引的叶子节点存储了索引和数据

而非聚集索引的叶子节点仅存储索引和对应数据的地址

## 联合/组合索引 ##

**联合索引与单一索引**

用3个列创建联合索引是否等价于在3个列上单独创建索引？

  否，**如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引，它的限制能力也肯定远远低于firstname、lastname、age这三个列上的多列索引。**

当我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。它相当于我们创建了(firstname，lastname，age)、(firstname，lastname)以及(firstname)这些列组合上的索引。

"最左前缀":从最左面的开始组合。	

**故：在使用联合索引时，为避免全表扫描，需要注意最左前缀的条件**

在创建索引时，尽量使用自增列(避免分叉，参考b+ tree 添加)

### 磁盘存取原理 ###


> 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

-来自[BTree和B+Tree详解](https://www.cnblogs.com/vianzhang/p/7922426.html)

- 磁盘存取原理
	- 寻道时间(速度慢，废时) *即找到对应的磁盘块是一个费时的操作* *一次寻道相当于一次I/O*
	- 旋转时间(速度较快) *磁盘块是一个类似于盘状的区块，我们的数据是存储在盘上不同的扇区中 所以需要通过旋转来查找数据对应的扇区，这个过程是非常快的* *Kafaka的吞吐量快跟这个有关*



> RAM(内存) 与 硬盘进行I/O时 数据交互的数据量有限(单位为页，与配置相关)

 **为什么B+Tree 的非叶子节点不存放数据 而是冗余一份索引字段?**✨✨✨
	
  由于硬盘与RAM一次数据交互的数据量有限，那么当一个节点存放了大量数据或是一个表的字段过多时，任然可能存在需要多次数据交互(I/O) 才能查找到想要的值

  而B+Tree的非叶子节点不存放数据，大大的减少了占用空间，且一个节点可以存储更多的索引*可以增加度*，减少了一个节点多次I/O的情况，从而提高效率。

 **为什么非主键索引(辅助索引)的叶子节点存储的是主键值而不是整行数据？**

  若是存储整行数据 则插入数据时 需要维护多个索引，大大增大了复杂性

  一致性(为了与主键索引保持一致)

  节省空间
  
 **为什么InnoDB表必须有主键？**

  因为表数据文件本身就是按(主键)B+Tree组织的一个索引结构文件，*如果没有主键，InnoDB会自动帮你选择可以作为主键的一列作为主键，如果不存在则创建一个主键*

 **为什么推荐使用整型的自增主键/为什么不使用uuid？**
  
- int比较快于string比较(ASCLI)
- 页面利用更充分(添加数据时，若需要创建新的一页，则会创建完整的一页而不是根据数据的大小而创建),则范围查找更快速(因为页不会出现多余的空间，导致增加频繁查询页)
- 若新增时插入之前的节点，可能会导致多个节点分列，若是数据在磁盘中，还会造成多次磁盘IO

 **MyISAM与InnoDB的区别**
 
  InnoDB的节点存储数据行(聚集索引)，而MyISAM仅存储数据地址(非聚集索引)

  MyISAM通过地址查找数据(回表)

 **有什么办法不回表**

  通过覆盖索引

### in 与 exists ###

 **小表驱动大表**

	SELECT * FROM A WHERE a.extId IN (SELECT id FROM B)

  <==> 等价于

	SELECT id FROM B
	SELECT * FROM A WHERE a.extId IN ...

 当表B的数量级远低于表A的数量级时，IN 优于 EXISTS