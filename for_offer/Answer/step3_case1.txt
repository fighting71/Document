 3.根据2进行计划定制

   公司名字是**物联网，那么所要求的项目经验期望值应该是与物联网相关
   先去了解下物联网的定义：

    物联网（ IoT ，Internet of things ）即“万物相连的互联网”，是互联网基础上的延伸和扩展的网络，将各种信息传感设备与互联网结合起来而形成的一个巨大网络，
    实现在任何时间、任何地点，人、机、物的互联互通 [2]  。

    物联网是新一代信息技术的重要组成部分，IT行业又叫：泛互联，意指物物相连，万物万联。
    由此，“物联网就是物物相连的互联网”。这有两层意思：
        第一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；
        第二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信。
    因此，物联网的定义是通过射频识别、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，
    以实现对物品的智能化识别、定位、跟踪、监控和管理的一种网络

   大概就是与实物进行操作？这方面没啥经验呢... pass

   精通C#
    1.从语言特性出发
        根据 https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/introduction 官方介绍
        C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。

        什么是面向对象？
            面向对象就是将万物看成生活中的具体对象，以人的思维去进行设计开发

        面向对象有什么特点？
            封装：把客观事物封装成类
            继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
            多态：是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

        什么是面向组件？
            面向组件就是，所有的小功能看成是一类组件，组件与组件使用者之间使用接口定义

        它与面向对象有何不同？

            原文地址：http://blog.csdn.net/teamlet/article/details/1995916

            1、面向对象中，对象之间的交互是细粒度的，通过单个消息进行交互； 
            面向组件中组件的交互是通过接口连接进行交互，接口内含有多个消息，接口不同则需要适配。 
            比如，信件一封一封的送，是对象之间的交互，信件一次性送完是组件交互。

            2、组件的粒度比对象要大，在面向对象系统设计中，对象是构建系统的基本建筑材料；面向组件系统开发中，组件是系统的基本建筑块；
            组件有点类似子系统的概念，把一组相关的对象封装起来对外提供服务；组件的存在增加了信息的隐蔽程度，
            减少了馈入上层信道的信息数量，从而增加了系统的稳定性；

            2、面向对象中强调封装，继承，多态 ；对象是类的实例，说到对象，往往是指源代码级的类的定义及其实现；
            在面向组件强调封装，在复用方面更多的是强调黑盒复用。组件中，接口的概念特别被强调。接口是组件的和组件使用者之间的契约；
            接口的确定使得组件的开发者和使用者得以分开。

            3、组件集中关注业务的职责，明确业务边界；对象关注同一业务的所有方面。 
            假如业务复杂的话，同一个概念实体，可能包含1000个属性，而这1000个属性可以分类成多个方面， 
            用面向对象方法，那么针对这1000个属性的操作，就会封装在这个对象里，结果所有操作因为所针对的属性捆绑，而捆绑，不能达到部分重用。 
            组件提供了更好的方式，针对这1000个属性的操作按职责分在不同的业务组件里，同时部分有公用可能的组件也可针对其他业务的提供某些方面的重用。

            4、 作为构建系统的基本建筑块，组件需要容器的帮助。
            容器为组件提供了运行环境，使组件能在一个较高的平台上完成自己最擅长的工作而不用考虑过多的底层细节。
            在组件中往往要实现一些容器所需的回调方法，来进行容器与组件间的沟通。
            容器也向组件提供一些公用的接口，使组件能够使用容器提供的服务（事务，安全等等）。
            容器的存在使得组件的使用者与组件的组装（配置)者得以分开。组件总是一定容器内的组件。
            由于组件生活在容器中，组件的管理尤其是生命周期的管理就成了容器的职责。生存在容器中，组件的状态（state）、持久性、通信方式也是必须要考虑的一些问题。
            由此产生了组件的类别。

            5、领域模型本身反映了现实世界的根本复杂性，组件针对的是领域模型的某个方面的相关属性和相关操作。
            就像面向方面思想一样，核心关注的是概念实体本身，方面则是按逻辑相关性分组的相关属性和相关操作。
            不同类型的实体核心关注的是不一样的，但一定某几个非核心方面存在类似。对于实现来说，可以为每个方面申明一个父类，然后从多个方面继承。

        什么？项目中没见过C#自带的面向组件

            去api中搜一下Component ， 看看它的派生类(据某大佬说国外很火，但是国内使用少，所以并不知名)

                System.Data.Common.DataAdapter
                System.Data.Common.DbCommand
                System.Data.Common.DbConnection
                ...

            用过ado.net的应该都知道这些类，多的就略过了

            https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.component?view=netframework-4.8

    2.从功能上看：

        a.泛型 

            一个既能带来约束，又能带来便利的功能
            其底层：https://www.cnblogs.com/kid-li/archive/2006/11/29/577045.html
                C#泛型能力有CLR在运行时支持：C#泛型代码在编译为IL代码和元数据时，采用特殊的占位符来表示范型类型，并用专有的IL指令支持泛型操作。
                而真正的泛型实例化工作以“on-demand”的方式，发生在JIT编译时。
                
                1、第一轮编译时，编译器只为Test<T>类型产生“泛型版”的IL代码与元数据——并不进行泛型的实例化，T在中间只充当占位符。
                例如：Test类型元数据中显示的<!T>

                2、JIT编译时，当JIT编译器第一次遇到Test<int>时，将用int替换“范型版”IL代码与元数据中的T——进行泛型类型的实例化。
                例如：Main函数中显示的<int>

                3、CLR为所有类型参数为“引用类型”的泛型类型产生同一份代码；但是如果类型参数为“值类型”
                ，对每一个不同的“值类型”，CLR将为其产生一份独立的代码。因为实例化一个引用类型的泛型，
                它在内存中分配的大小是一样的，但是当实例化一个值类型的时候，在内存中分配的大小是不一样的。


            C#泛型特点：

                1、如果实例化泛型类型的参数相同，那么JIT编辑器会重复使用该类型，因此C#的动态泛型能力避免了C++静态模板可能导致的代码膨胀的问题。

                2、C#泛型类型携带有丰富的元数据，因此C#的泛型类型可以应用于强大的反射技术。

                3、C#的泛型采用“基类、接口、构造器，值类型/引用类型”的约束方式来实现对类型参数的“显示约束”，提高了类型安全的同时，
                也丧失了C++模板基于“签名”的隐式约束所具有的高灵活性

            其他应用：泛型缓存

        b.委托

            委托是一种类型
            其底层/原理：
                可将委托看做为C#封装的一种回调函数...
            

        c.异步、多线程、线程池

            异步：非同步，其实现原理是一个状态机，通过线程池来进行管理

            多线程：一个进程可存在多个线程，一个主线程，多个异步线程
                扩展：一个CPU在同一时间只能在执行一个线程

        e.锁

            在多线程中，每个线程都有自己的内存栈，称为线程内存，而所有线程共用同一主线程。
            当操作同一数据时，可能存在写入线程内存而还没刷入主线程的情况从而可能导致同一时间不同线程数据不一致

        f.运算符(重载)

            操作符重载，自增隐式转换、显式转换等

        g.预编译

            #if ... 可用于区别开发、测试、正式等

        h.clr

            

        i.GC

            内存分为 堆与栈，其中堆分为L1,L2,L3
            当GC回收时==>大概
             扫描并清理L1 
              L1满了 ==> 
               扫描并清理L2
                L2满了 ==>
                 扫描并清理L3
                  L3满了 ==> 堆栈溢出或加内存吧
               ....
              L1未满
               将扫描后剩余的L1放入L2
               ...

           引用计数：如何判断对象是否可回收：
            是否有变量指向，其中大对象直接存储在L3中



   熟悉Asp.net MVC、Asp.net Web API

    我们经常在某个方面把两者混为一谈，那么就先看看两者的区别

    ASP.NET MVC vs ASP.NET API source:https://www.cnblogs.com/codefly/articles/11045133.html

        MVC主要用来构建网站，既关心数据也关心页面展示，而Web API只关注数据
        Web API支持格式协商，客户端可以通过Accept header通知服务器期望的格式
        Web API支持Self Host，MVC目前不支持
        Web API通过不同的http verb表达不同的动作(CRUD)，MVC则通过Action名字表达动作
        Web API内建于ASP.NET System.Web.Http命名空间下，MVC位于System.Web.Mvc命名空间下，因此model binding/filter/routing等功能有所不同
        Web API非常适合构建移动客户端服务

   熟悉EF Core
    
    EF vs EF Core https://docs.microsoft.com/zh-cn/ef/efcore-and-ef6/

        EF Core
            Entity Framework Core (EF Core) 是适用于 .NET 的新式对象数据库映射器。 它支持 LINQ 查询、更改跟踪、更新和架构迁移。
            EF Core 通过数据库提供程序插件模型与 SQL Server/SQL Azure、SQLite、Azure Cosmos DB、MySQL、PostgreSQL 和更多数据库配合使用。
        EF6
            Entity Framework 6 (EF6) 是专为 .NET Framework 设计的对象关系映射器，但支持 .NET Core。 EF6 是一款受支持的稳定产品，但我们不再对其进行积极开发。

    EF Core 就是一种orm框架，核心构建/解析表达式树和实体追踪(实体状态)
    对于不同的数据库使用不同的provide

    那么内容就可以升级到==> 熟悉 ORM 框架

    ORM 有什么优势？

        a.方便迁移：由于所有操作通过类的映射关系进行操作，通过不同的provide进行具体的sql解析，故只要有相对应的provide提供，你就可以应用到对应的数据库。实现无缝切换
        b.方便维护：在ORM中所有的表是映射到具体的类，故在代码中更加容易查找到表与表的关系，方便连接(join),表和字段的注释、约束等

    ORM 有什么劣势？

        a.看天吃饭:
            若是当前orm框架版本没有对应的provide，那么理论上是无法使用此orm
            若是框架中存在bug,那么你只能默默等待bug修复
            由于所有sql都是统一通过表达式树生成，那么在使用不熟练时，复杂查询极易出现低效sql
            简而言之：版本问题，框架熟练度(在ef中此熟练度还与版本有关,不同版本可能存在较大差异)问题,框架若存在bug

        除了要熟悉sql优化还要熟悉ORM框架的操作(底层级别)...

        以你或许需要为了框架调整项目，而不是为了项目选择框架


   熟悉至少一种关系型数据库

    MySql/Sqlserver

    t-sql、存储过程、索引、约束、视图、事务、自定义函数...

    简单来说就常规的crud...

    索引
        聚集与非聚集

         其区别就是逻辑顺序与磁盘上行的物理存储顺序相同还是不同

         所谓逻辑顺序就相当于索引存储顺序，物理顺序就是磁盘的存储顺序。

         故在聚集索引中 叶子节点既存储索引列也存储对应的行数据，反之非聚集就是叶子节点存储索引列和对应的物理地址

        覆盖索引： 使用索引中的列的值做为数据行的值，在使用非聚集索引时，若查找的列存在于索引上，可通过此种方式避免通过物理地址再查值

        复合索引： 可以在多个列上建立索引

   B/S 架构：

    网络通讯(Socket) [大Boss... 了解略过]

        OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表达层、应用层... 

    restful

    oauth2/授权认证
    
    如何处理分布式Session共享
        1.将标识放在一个都可以访问的位置-->SharePoint Online
        2.将一些可认证身份的数据放入标识中-->JWT

    路由/拦截器


 感觉这些就差不多了，够扯皮三十分钟~

 其余的应该就是中间件（mq）、缓存数据库、微服务架构、Socket网络通信了

res: