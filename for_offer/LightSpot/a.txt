<异步>

异步的产生：项目中存在比较耗时的操作，会长时间占用线程资源，从而在繁忙繁忙时容易出现WEB线程长时间被占用时，
请求会由于线程池而阻塞，同时产生大量的线程，最终响应时间变长

得出结论，要提高系统响应时间与并发处理数，应尽可能减少WEB线程的等待。

如何减少WEB线程的等待呢，那就应该尽早的结果ProcessRequest方法，前一篇中讲到，对于一些需要等待完成的任务，可以使用异步方法来做，
于是我们可以在ProcessRequest中调用异步方法，但问题是当ProcessRequest结束后，请求处理也即将结束，
一但请求结束，将没有办法在这一次请求中返回结果给客户端，但是此时，异步任务还没有完成，当异步任务完成时，也许再也没有办法将结果传给客户端了。

我们需要的方案是，处理请求时可以暂停处理（不是暂停线程），并保持客户端连接，在需要时，向客户端输出结果，并结束请求。

【注意】由于WEB线程属于线程池线程，因此，如果在线程池中加入任务，将同样会影响并发处理数。
而在异步处理程序中，由线程池来完成异步将得不到任何本质上的提升，因此在异步处理程序中禁止操作线程池
（ThreadPool.QueueUserWorkItem、delegate.BeginInvoke，Task.Run等）。如果确定需要使用多线程来处理大量的计算，需要自己开启线程或实现自己的线程池。

虽然等待工作交由另一线程去操作，但是该线程与WEB线程性质相同，同样会导致其他请求阻塞。

【思考】如果我们的程序中的确需要有大量的计算，那么可以考虑将这些计算提取到独立的应用服务器中，然后通过网络IOCP异步调用，达到WEB服务器的高吞吐量与系统的平行扩展性。

异步的延伸：多线程、线程池

clr线程类型:工作线程、IO线程

clr线程的创建会消耗那些资源？

参考：https://www.cnblogs.com/wisdomqq/archive/2012/03/29/2417723.html

<索引>

B-Tree vs B+-Tree

B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。
而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，
增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。